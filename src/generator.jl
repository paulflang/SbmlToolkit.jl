relu(x) = x > 0 ? x : zero(x)
plog(x) = log(relu(x))

function generate_functions(name::String, ml::CellModel, jac=true; p=list_params(ml), u0=list_initial_conditions(ml), level=1)
    io = open(name, "w")

    write(io, "# this file is auto-generated by SbmlToolkit (https://github.com/SciML/SbmlToolkit.jl)\n")
    write(io, "# 2020 Shahriar Iravanian (siravan@svtsim.com)\n\n")
    write(io, "𝐻(x) = (x >= zero(x) ? one(x) : zero(x))\n\n")

    generate_lists(io, p, u0)
    generate_f(io, ml, p, u0)
    if jac
        generate_j(io, ml, p, u0; level=level)
    end
    close(io)
end

function generate_preabmle(io, iv, p, u0)
    write(io, "\t$(iv) = tₚ\n\n")

    write(io, "\t# state variables:\n")
    for (i,v) in enumerate(u0)
        write(io, "\t$(first(v)) = uₚ[$i]\n")
    end

    write(io, "\n\t# parameters:\n")

    for (i,v) in enumerate(p)
        write(io, "\t$(first(v)) = pₚ[$i]\n")
    end

    write(io, "\n")
end

function generate_lists(io, p, u0)
    write(io, "# initial conditions\n")
    write(io, "u0 = [" * join(last.(u0), ", ") * "]\n\n")

    write(io, "# parameters\n")
    write(io, "p = [" * join(last.(p), ", ") * "]\n\n")
end

function generate_algebraics(io, ml::CellModel)
    write(io, "\t# algebraic equations:\n")

    # topolical sorting of the algebraic equations
    s = Set{Any}(values(ml.vars))
    setdiff!(s, [x.lhs for x in  ml.alg])
    algs = copy(ml.alg)
    k = 0

    while !isempty(algs)
        a = algs[1]

        if prerequisite(s, a.rhs)
            # the prerequisites of a.rhs are satisfied
            # output the code for a and remote it from the queue
            eq = simplify(a.rhs)
            write(io, "\t$(a.lhs) = $eq\n")
            push!(s, a.lhs)
            algs = algs[2:end]
            k = 0
        else
            # at least one prerequisites of a.rhs is not satisfied
            # move a to the end of the queue
            algs = [algs[2:end]; a]
            k += 1
            if k > length(algs)
                error("a circular relationship in the algebraic equations detected")
            end
        end
    end
end

function generate_f(io, ml::CellModel, p, u0)
    write(io, "function f!(duₚ, uₚ, pₚ, tₚ)\n")

    generate_preabmle(io, ml.iv, p, u0)

    generate_algebraics(io, ml)

    write(io, "\n\t# system of ODEs:\n")

    # eqs, v = flat_equations(ml; level=1)

    for a in ml.eqs
        eq = simplify(a.rhs)
        write(io, "\t∂$(arguments(a.lhs)[1]) = $eq\n")
    end

    write(io, "\n\t# state variables:\n")

    for (i,v) in enumerate(u0)
        write(io, "\tduₚ[$i] = ∂$(first(v))\n")
    end

    write(io, "\tnothing\n")
    write(io, "end\n\n")
end

function generate_j(io, ml::CellModel, p, u0; level=1)
    write(io, "function J!(J, uₚ, pₚ, tₚ)\n")

    generate_preabmle(io, ml.iv, p, u0)

    write(io, "\t# Jacobian:\n")

    eqs, v = flat_equations(ml; level=level)
    n = length(v)

    for i = 1:n
        for j = 1:n
            eq = simplify(derivate(eqs[i].rhs, v[j]))
            if !iszero(eq)
                write(io, "\tJ[$i,$j] = $eq\n")
            end
        end
    end

    write(io, "\tnothing\n")
    write(io, "end\n\n")
end


#############################################################################

function derivate(op::Symbolic, v::Symbolic)
    n = length(arguments(op))

    iseq = isequal(op, v)
    if op isa Sym && iseq
        return 1
    elseif n == 0
        if iseq
            return 1
        else
            return 0
        end
    elseif n == 1
        a = derivate(arguments(op)[1], v)
        δa = ModelingToolkit.derivative(op, 1)
        return a * δa
    elseif n >= 2
        l = []
        for i = 1:n
            push!(l, derivate(arguments(op)[i], v) * ModelingToolkit.derivative(op, i))
        end
        return Term{Real}(+, l)
    end
end

derivate(::Number, ::Symbolic) = 0

import Base.isconst

isconst(x::Number) = true
isconst(x::Symbolic) = false
isminusone(x::Symbolic) = false
isminusone(x) = isone(-x)

simplify(x::Equation) = x.lhs ~ simplify(x.rhs)

function simplify(op::Symbolic)
    n = length(arguments(op))

    if n == 0
        return op
    elseif n == 1
        return simplify_unary(op)
    elseif n == 2
        return simplify_binary(op)
    else
        return simplify_nary(op)
    end
end

function simplify_unary(op::Symbolic)
    return Term{Real}(operation(op), [simplify(arguments(op)[1])])
end

function simplify_binary(op::Symbolic)
    g = operation(op)
    x = simplify(arguments(op)[1])
    y = simplify(arguments(op)[2])

    if g == +
        if iszero(x)
            return y
        elseif iszero(y)
            return x
        elseif isconst(x) && isconst(y)
            return x.value + y.value
        else
            return x + y
        end
    elseif g == -
        if iszero(x)
            return -y
        elseif iszero(y)
            return x
        elseif isconst(x) && isconst(y)
            return x.value - y.value
        else
            return x - y
        end
    elseif g == *
        if iszero(x)
            return x
        elseif iszero(y)
            return y
        elseif isone(x)
            return y
        elseif isone(y)
            return x
        elseif isminusone(x)
            return -y
        elseif isminusone(y)
            return -x
        elseif isconst(x) && isconst(y)
            return x.value * y.value
        elseif isconst(x)
            # we reverse the order of operands here to suppress implicit multiplication
            # as it can cause ambiguity if a number literal is followed by a variable, whose
            # name starts with E, e, or f and the second letter is a digit
            return y * x
        else
            return x * y
        end
    elseif g == /
        if iszero(x)
            return x
        elseif iszero(y)
            error("divide by zero")
        elseif isone(y)
            return x
        elseif isminusone(y)
            return -x
        elseif isconst(x) && isconst(y)
            return x.value / y.value
        else
            return x / y
        end
    elseif g == ^
        if iszero(x)
            return x
        elseif iszero(y)
            return 1
        elseif isone(x)
            return x
        elseif isone(y)
            return x
        elseif isconst(x) && isconst(y)
            return x.value ^ y.value
        else
            return x ^ y
        end
    else
        Term{Real}(g, [x, y])
    end
end

function simplify_nary(op::Symbolic)
    g = operation(op)
    x = simplify(arguments(op)[1])
    y = simplify(Term{Real}(g, arguments(op)[2:end]))

    if g == +
        if iszero(x)
            return y
        else
            return x + y
        end
    elseif g == *
        if iszero(x)
            return x
        elseif isone(x)
            return y
        elseif isminusone(x)
            return -y
        else
            return x * y
        end
    else
        return Term{Real}(g, [x,y])
    end
end

##############################################################################

prerequisite(::Set, ::Number) = true
prerequisite(s::Set, x::Equation) = prerequisite(s, x.rhs)

function prerequisite(s::Set, op::Symbolic)
    if length(arguments(op)) == 0
        return !(op isa Sym) || op ∈ s
    else
        return all(map(x -> prerequisite(s,x), arguments(op)))
    end
end
